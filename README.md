# Cramp - это...

![alt text](https://i.ibb.co/ynxqVp7/cramp.jpg)

...Архитектурный фреймворк, который заботиться о гибкости игровых приложений. Cramp привносит в игровые приложения архитектуру основанную на паттерне Entity-Component-System, делая процесс разработки максимально гибким, а приложение устойчивым. Фреймворк решает исключительно архитектурные и структурные задачи по организации файлов и кода в проекте. В нем нет инструментов, которые помогут разработчику работать с графикой, физикой, звуками, анимациями и другими вещами. Сделано это для того, чтобы разработчик мог использовать с Cramp те инструменты, к которым он привык. Более того, Cramp можно использовать в разработке игровой логики даже на сервере без риска притащить в серверное окружение лишние вещи, которые там ни к чему.


## Против чего мы сражаемся?

Главный враг любого разработчика, менеджера, тестировщика и всей команды - изменения. Каждый раз, когда в игровой механике что-то меняется, а подобный сценарий неизбежен, разработчики могут столкнутся с множеством проблем, начиная от простых багов, заканчивая переписью огромной части приложения под новые требования. И на решение этих проблем требуется время. Прибавим сюда еще время на тестирование и отладку… Разумеется, опытные команды разработчиков сами проектируют архитектуру так, чтобы не переживать за последствия от изменений игровой логики, однако, на это также уходит львиная доля времени всей разработки. Cramp экономит время на проектирование и оберегает команду от последствий, причина которых - изменения. Достигается это за счет низкой связности всех частей приложения, подробнее о чем будет рассказано в разделе “Кратко об Entity-Component-System”.

## Кому и для каких проектов подойдет Cramp

Фреймворк будет полезен небольшим студиям разработчиков, создающих казуальные и гипер-казуальные игры. Инди-разработчикам для их независимых проектов любой сложности и величины. А также отлично подойдет под социальные-казино и любой другой гемблинг. Впрочем, никаких ограничений фреймворк не накладывает и с его помощью может быть создана абсолютно любая игра кем угодно. Фреймворк Cramp полностью открыт и распространяется свободно.


# Содержание 
 [1. Установка](https://github.com/YettiKetchup/cramp#%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0)

 [1.2. Интеграционные бойлерплейты](https://github.com/YettiKetchup/cramp#%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B1%D0%BE%D0%B9%D0%BB%D0%B5%D1%80%D0%BF%D0%BB%D0%B5%D0%B9%D1%82%D1%8B)

 [1.2.1. Биндинги типов в интеграциях](https://github.com/YettiKetchup/cramp#%D0%B1%D0%B8%D0%BD%D0%B4%D0%B8%D0%BD%D0%B3%D0%B8-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B2-%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%D1%85)

 [2. Кратко об Entity-Component-System.](https://github.com/YettiKetchup/cramp/#%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%BE-%D0%BE%D0%B1-entity-component-system)

 [2.1. Думай Компонентами, а не свойствами!](https://github.com/YettiKetchup/cramp/#%D0%B4%D1%83%D0%BC%D0%B0%D0%B9-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8-%D0%B0-%D0%BD%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D0%BC%D0%B8)

 [2.2. Логика никак не связана с объектами!](https://github.com/YettiKetchup/cramp#%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0-%D0%BD%D0%B8%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B5-%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%B0-%D1%81-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%D0%BC%D0%B8)

 [2.3. Секрет гибкости оказывается прост.](https://github.com/YettiKetchup/cramp#%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82-%D0%B3%D0%B8%D0%B1%D0%BA%D0%BE%D1%81%D1%82%D0%B8-%D0%BE%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BF%D1%80%D0%BE%D1%81%D1%82)

 [3. Как устроен Cramp Framework.](https://github.com/YettiKetchup/cramp#%D0%BA%D0%B0%D0%BA-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD-cramp-framework)

 [3.1 Компоненты в Cramp.](https://github.com/YettiKetchup/cramp#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D0%B2-cramp)

 [3.1.1. Пример создания Компонента в Cramp.](https://github.com/YettiKetchup/cramp#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0-%D0%B2-cramp)

 [3.1.2. Компоненты-тэги в Cramp.](https://github.com/YettiKetchup/cramp#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%82%D1%8D%D0%B3%D0%B8-%D0%B2-cramp)

 [3.1.3. Хорошие практики при работе с Компонентами.](https://github.com/YettiKetchup/cramp#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8)

 [3.2. Сущности в Cramp.](https://github.com/YettiKetchup/cramp#%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B2-cramp)

 [3.2.1. Пример создания Сущности в Cramp.](https://github.com/YettiKetchup/cramp#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B2-cramp)

 [3.2.2. Кэширование Компонентов в Сущности.](https://github.com/YettiKetchup/cramp#%D0%BA%D1%8D%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%B2-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B8)

 [3.2.3. Доступ к Ноде игрового движка.](https://github.com/YettiKetchup/cramp#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D0%BD%D0%BE%D0%B4%D0%B5-%D0%B8%D0%B3%D1%80%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B4%D0%B2%D0%B8%D0%B6%D0%BA%D0%B0)

 [3.2.4. Фабрики Сущностей.](https://github.com/YettiKetchup/cramp#%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B8-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)

 [3.2.5. Хорошие практики при работе с Сущностями.](https://github.com/YettiKetchup/cramp#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D1%8F%D0%BC%D0%B8)

 [3.3. Хранилища Сущностей](https://github.com/YettiKetchup/cramp#%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)

 [3.3.1. Пример использования Хранилища Сущностей.](https://github.com/YettiKetchup/cramp#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0-%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9)

 [3.3.2. Создание Хранилищ через Фабрики.](https://github.com/YettiKetchup/cramp#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B8)

 [3.3.3. Комбинирование Хранилищ.](https://github.com/YettiKetchup/cramp#%D0%BA%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89)

 [3.3.4. Хорошие практики при работе с Хранилищами.](https://github.com/YettiKetchup/cramp#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89%D0%B0%D0%BC%D0%B8)

 [3.4. Системы в Cramp.](https://github.com/YettiKetchup/cramp#%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B2-cramp)

 [3.4.1. Пример создания Системы в Cramp.](https://github.com/YettiKetchup/cramp#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B2-cramp)

 [3.4.2. Объект фильтрации Компонентов.](https://github.com/YettiKetchup/cramp#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82-%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)

 [3.4.3. Хорошие практики при работе с Системами в Cramp.](https://github.com/YettiKetchup/cramp#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D0%BC%D0%B8-%D0%B2-cramp)

 [3.5. Контейнеры Систем.](https://github.com/YettiKetchup/cramp#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC)

 [3.5.1. Пример создания и запуска Контейнера.](https://github.com/YettiKetchup/cramp#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0)

 [3.5.2. Декораторы Систем.](https://github.com/YettiKetchup/cramp#%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC)

 [3.5.3. Декораторы фильтра.](https://github.com/YettiKetchup/cramp#%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D0%B0)

 [3.5.4. Отложенный запуск Систем.](https://github.com/YettiKetchup/cramp#%D0%BE%D1%82%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC)

 [3.5.5. Хорошие практики при работе с Контейнерами.](https://github.com/YettiKetchup/cramp#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0%D0%BC%D0%B8)

 [3.6. Реакция на изменение Компонентов.](https://github.com/YettiKetchup/cramp#%D1%80%D0%B5%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-%D0%BD%D0%B0-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)

 [3.6.1. Хорошие практики при работе с Реакциями на изменения Компонентов.](https://github.com/YettiKetchup/cramp#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D0%BF%D1%80%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-%D1%80%D0%B5%D0%B0%D0%BA%D1%86%D0%B8%D1%8F%D0%BC%D0%B8-%D0%BD%D0%B0-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)

 [3.7. Модули Cramp.](https://github.com/YettiKetchup/cramp#%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B8-cramp)

 [3.8. Контроль состояния Компонентов.](https://github.com/YettiKetchup/cramp#%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)

 [4. Так как же это все работает.](https://github.com/YettiKetchup/cramp#%D1%82%D0%B0%D0%BA-%D0%BA%D0%B0%D0%BA-%D0%B6%D0%B5-%D1%8D%D1%82%D0%BE-%D0%B2%D1%81%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82)

 [4.1. Простой пример.](https://github.com/YettiKetchup/cramp#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)

 [4.2. Более подробные примеры.](https://github.com/YettiKetchup/cramp#%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B)


# Установка

Просто скопируйте этот репозиторий в свой проект. Или воспользуйтесь одним из интеграционных бойлерплейтов. 


## Интеграционные бойлерплейты

CocosCreator 2x - https://github.com/YettiKetchup/cc-cramp-boilerplate

CocosCreator 3x - В процессе разработки...

PlayCanvas - В процессе разработки...

Nest - https://github.com/YettiKetchup/nest-cramp-boilerplate

Пользователь без проблем сможет сам синтегрировать Cramp в свой проект, следуя примеру одного из готовых бойлерплейтов.

### Биндинги типов в интеграциях

Для того, чтобы без проблем переносить некоторые Компоненты, Сущности и Системы между проектами и окружениями, рекомендуется прописать биндинги типов. Пример реализации биндингов можно увидеть в одном из официальных интеграционных шаблонов в файле bindings.ts в корневой папке модулей Cramp. 

Биндинги типов - очень простой, но мощный инструмент позволяющий переносить готовые Компоненты, Системы и Сущности между проектами, даже, если они находятся в разных окружениях. Биндинги бывают полезны в тех случаях, когда нам потребовалось часть игровой логики перенести с сервера на клиент, или обратно. Либо, мы можем создать отдельный репозиторий с общей для клиента и сервера логикой и использовать его в качестве сабмодуля. Правда, в таком случае придется переопределять биндинги общего репозитория извне, но это все равно лучше, чем дублировать одну и ту же логику. Однако, стоит понимать, что не все Системы, Компоненты и Сущности могут быть перенесены в иное окружение, поскольку часть их них ссылается и использует API того окружения, в котором они были изначально написаны. То есть, переносу подлежат высоко-абстрактные Компоненты, Системы и Сущности. Стоит об этом помнить при проектировании игрового приложения.


# Кратко об Entity-Component-System.

Это шаблон проектирования, который разделяет данные и логику между собой, а также привносит в разработку элементы парадигмы Data Driven Development. Если в классическом OOP-подходе мы храним данные об объекте и его логику вместе, в одном классе, то в DDD все наоборот. Мы держим логику и данные объекта отдельно друг от друга. Звучит немного сложно, но на практике все куда проще. Отличия между классическим подходом и с использованием Entity-Component-System лучше всего будут видны на примере. 

Как выглядит класс игрока в классическом OOP-подходе:
```
class Player {
	public health: number = 100;

	public increaseHealth(value: number): void {
		this.health += value;
	}

	public decreaseHealth(value: number): void {
		this.health -= value;
	}
}
```
Как видно из примера, класс Player хранит в себе и данные и логику работы с ними. Пока у нас всего один игровой объект с таким небольшим функционалом все выглядит достаточно невинно. Однако, если мы начнем наращивать функционал, наш класс будет расти. Если мы захотим сделать другие объекты со схожими свойствами и функционалом, нам придется писать большое количество интерфейсов и реализовывать их для каждого объекта по-отдельности, либо описывать большое количество поведенческих классов, заботясь о грамотной передачи их в основной класс через механизмы внедрения зависимостей, что приводит к разрастанию кодовой базы и огромному количеству уровней абстракции. Кратко говоря, о недостатках проектирования приложений в OOP-стиле было сказано уже многое и повторяться нет смысла. Но стоит подчеркнуть, что подобное неизбежно ведет к огромному количеству ненужного абстрактного кода, повышению порога входа для новых участников команды и высокой связности объектов между собой, даже тех, которые по логике вещей не должны иметь жесткой связи. И на все это тратится огромное количество времени  всей команды в целом.

Теперь посмотрим на то, как выглядят игровые объекты, если будет использован шаблон Entity-Component-System:
```
class HealthComponent implements IComponent {
	public value: number = 100;
}

class PlayerEntity implements IEntity {
	public components: IComponent[] = [new HealthComponent()]
}

class IncreaseHealthSystem extends ECSSystem {
	public execute(value: number): void {
		const entities: IEntity[] = this.get([HealthComponent]);
		entities.forEach(e => {
			const healthComponent = e.getComponent(HealthComponent);
			healthComponent.value += value;
		})
	}
}
```
Тут уже видно, что игровой объект, его данные и логика держаться обособленно и практически никак не связаны между собой. Все данные игрового объекта хранятся в Компонентах. Вся логика в Системах. Сам же игровой объект ни что иное как хранилище никак не связанных между собой Компонентов. В то время как Система не работает с конкретным игровым объектом, а с теми, кто хранит в себе нужный Компонент. Рассмотрим подробнее.


## Думай Компонентами, а не свойствами!

Благодаря примерам выше мы уже можем видеть разницу хранения данных между двумя подходами. Если в классическом OOP все объекты наделяются свойствами, то в ECS - Компонентами. Компонент ни что иное как обычное хранилище данных без какой-либо логики внутри. Разумеется, нам никто не запрещает использовать геттеры и сеттеры, описывая логику преобразования и валидации данных внутри оных, но у Компонента не может быть каких-либо методов, которые принимали бы и возвращали какие-то другие данные. То есть, Компонент это исключительно структурная единица, без какого-либо функционала, хранящая в себе данные и только данные. 

Сам игровой объект преображается в Сущность. Сущность - это всего-навсего хранилище Компонентов. Именно Компонентами определяется тип Сущности. Для того, чтобы остальные части приложения понимали, что этот объект имеет здоровье и может быть как исцелен, так и уничтожен, нам всего навсего нужно определить в нем Компонент HealthComponent, вместо того, чтобы описывать свойства, методы или передавать логику извне. Проще говоря, Компоненты схожи со свойствами объекта. Например, мы как и свойствами Компонентами описываем объект автомобиля: автомобиль Красный, есть 4 колеса, двигатель и 3 двери. Но мы указываем эти свойства не напрямую в самом объекте, а где-то извне в Компонентах, которые и указываем в самой Сущности. Благодаря такому компонентному подходу мы можем наделять свойством health и связанным с ним логическим функционалом любые игровые объекты. И нам не придется как-то определять логику для новых объектов, все произойдет автоматически. 


## Логика никак не связана с объектами!

Хорошо, мы уже определили новый игровой объект путем сбора Сущностей из Компонентов. У нас есть Сущность PlayerEntity с Компонентом HealthComponent. Как же нам наделить его логикой? А никак. Сущности, читай игровые объекты, подобно их Компонентам, не могут иметь какой-либо игровой логики. И сама логика, то есть, Системы, ничего не знают о конкретных Сущностях. 

Система - это логическая часть игрового приложения построенного на базе ECS-шаблона. Именно тут происходят все манипуляции с данными игровых объектов. Однако, это не происходит напрямую. Для того, чтобы понять как это работает, вернемся к примеру выше.

```
class IncreaseHealthSystem extends ECSSystem {
	public execute(value: number): void {
		const entities: IEntity[] = this.get([HealthComponent]);
		entities.forEach(e => {
			const healthComponent = e.getComponent(HealthComponent);
			healthComponent.value += value;
		})
	}
}
```
Подробно о том, что здесь происходит: Система запрашивает ВСЕ Сущности у которых есть компонент HealthComponent. Далее у каждой Сущности запрашивается требуемый Компонент, это HealthComponent. И уже с ним происходят все преобразования. 

То есть, получается, что Система знать не знает ни о каком PlayerEntity, как и PlayerEntity не знает о том, что у нее есть какая-то логика исцеления. Система получит все Сущности с компонентом HealthComponent, а это может быть не только PlayerEntity, но и EnemyEntity, NPCEntity, AnimalEntity и так далее. И для того, чтобы наделить новый игровой объект логикой связанной с исцелением или разрушением нам достаточно лишь добавить к ней компонент HealthComponent. За счет чего достигается невероятная гибкость при расширении. Как и наоборот, чтобы избавить игровой объект от такой логики все, что нам потребуется - удалить Компонент из Сущности.

## Секрет гибкости оказывается прост.

Пазл уже сложился и мы видим как ECS-архитектура добивается невероятной гибкости. Ведь Компоненты никак не связаны между собой. Сущности никак не связаны между собой. Системы никак не связаны между собой. И даже Системы и Сущности напрямую никак не связываются. Единственная прямая связь, которая существует, это связь между Сущностью и Компонентами, но это необходимо. Да и в таком случае игровой объект никак не связывается со свойствами напрямую. Таким образом, в нашем игровом приложении могут находится тысячи Компонентов, Систем и Сущностей измненеия которых никак не затрагивают друг-друга. Мы вольны добавлять и убирать у Сущностей Компоненты, можем описывать различные Системы для разного набора Компонентов и все это никак не будет влиять друг на друга. И каждый раз нам не нужно будет описывать дополнительные абстракции, думать о зависимостях, передаче данных и логики, переиспользовании и так далее. 

Благодаря ECS мы можем собирать объекты с уникальным поведением настолько просто, насколько это возможно, просто определив набор Компонентов у Сущности. А все Системы сами получат это игровой объект и смогут его “оживить”.


# Как устроен Cramp Framework.

В основном, Cramp старается следовать стандартной реализации ECS. В нем есть Компоненты, которые выполняют роль хранилища данных. Есть Сущности, которые хранят в себе набор Компонентов и предоставляют простой API для их добавления, удаления и получения. Есть Системы, в которых описывается логика для Сущностей с определенным набором Компонентов. Однако, разумеется, есть нюансы, поскольку Cramp задумывался как универсальное, внедряемое в различные окружения, решение. Что, к слову, никак негативно не влияет на расширяемость и основной принцип ECS. Также, Cramp предоставляет инструменты для удобной организации непрямого взаимодействия между Системами, хранения Сущностей и Систем, контроля порядка выполнения Систем и многое-многое другое о чем речь пойдет дальше.


## Компоненты в Cramp.

С идеологической точки зрения, Компоненты в Cramp это ровно те же самые Компоненты, что и в ECS, цель которых - хранить данные и ничего более. Реализация Компонента в Cramp всего навсего простой интерфейс наследующий тип Object без каких-либо дополнительных методов, полей и свойств. Сделано это для удобной интеграции в различные игровые движки и фреймворки. Например, в CocosCreator уже есть свои Компоненты, которые используются в Cramp как Компоненты самого фреймворка. Эти Компоненты используются как самим CocosCreator, так и фреймворком Cramp и являются гибридными. Это значит, что эти Компоненты могут нарушать правило ECS и хранить в себе не только данные, но и логику. Но это касается только тех объектов, которые были написаны разработчиками CocosCreator, либо взяты из third-party библиотек. Компоненты, которые были написаны самим пользователем должны четко следовать правилам ECS и содержать в себе исключительно данные, при этом сохраняя свою доступность как для Cramp, так и для CocosCreator.


### Пример создания Компонента в Cramp.

```
export default class HealthComponent implements IComponent {
	
	private _value: number = 0;

	public get value(): number {
		return this._value;
	}

	public set value(value: number) {
		if(value < 0) value = 0;
		this._value = value;
	}

	constructor(value: number = 100) {
		this._value = value;
	}
	
}
```
Вот так выглядит типичный Компонент Cramp. Разумеется, не всегда нужны геттеры, сеттеры и конструктор, поэтому можно их не прописывать. Но основная идея в том, что кроме данных в Компоненте больше ничего нет. Ни логики, ни ссылок на Сущности или другие Компоненты, ничего кроме данных. 


### Компоненты-тэги в Cramp.

Поскольку Компонент в Cramp необходим для того, чтобы указать Системам какой тип Сущностей им требуется для работы, нам необязательно хранить данные в Компоненте. Мы можем оставить его абсолютно пустым. Это бывает полезно, когда мы хотим снизить уровень абстракции у четко указать Системе, что мы хотим получать все Сущности  Игрока, например.

```
export default class PlayerComponent implements IComponent {}
```
Таким образом, мы можем заставить определенную Систему работать не со всеми объектами у которых есть HealthComponent, а со всеми объектами у которых есть Компоненты HealthComponent и PlayerComponent. Что позволит нам наделить объект Игрока уникальным поведением.


### Хорошие практики при работе с Компонентами.

* Не бойтесь дробить Компоненты на более мелкие. Более того, это необходимо для того, чтобы увеличить гибкость вашего игрового приложения. Например, если мы хотим установить максимальный порог значения жизней у игрового объекта, нам не нужно в Компоненте HealthComponent прописывать дополнительное поле maxValue. Лучше всего создать дополнительный Компонент MaxHealthComponent и наделить им все Сущности у которых возможен максимальный порог значения жизней. Таким образом, мы добьемся большего разнообразия игровых объектов: у каких-то объектов будет максимальный возможный порог значения жизней, у каких-то - нет. Если Компонент хранит в себе всего одно свойство - это нормально и даже приветствуется!
Не брезгуйте Компонентами-тегами. Когда мы дойдем до изучения Контейнеров и Фильтров в фреймворке Cramp, станет понятно, что Компоненты-теги могут сослужить хорошую службу в получении Сущностей некоторыми Системами. В Cramp предусмотрены специальные механизмы декорации фильтров Систем, которые позволяют модифицировать фильтры Системы извне, не меняя ее исходный код, что дает нам возможность использовать одну и ту же Систему в разные периоды игрового цикла для разных типов Сущностей.


## Сущности в Cramp.

Сущности в Cramp выполняют свою изначальную функцию хранения Компонентов. Более того, у Сущности есть небольшой API, который позволяет удобно добавлять, удалять и получать Компоненты. Также, есть возможность переопределить поведение Сущности при добавлении, удалении и получении Компонента, что бывает необходимо во время интеграции с игровыми движками.


### Пример создания Сущности в Cramp.

Сущности создаются из функции-конструктора. После создания мы можем передать все необходимые ей компоненты. Все достаточно просто.

```
import { v4 as uuidv4 } from 'uuid';

const id: string = uuidv4();
const player: IEntity<IComponent> = new BaseEntity(id);

player.components.push(
	new PlayerComponent(), 
	new HealthComponent(100)
);
```


### Кэширование Компонентов в Сущности.

Однако, есть небольшой секрет, касающийся работы с памятью. Для оптимизации выделения и очистки памяти все Компоненты внутри Сущности по-умолчанию кэшируются и при добавлении Компонентов к Сущности внутри самих Систем берутся из кэша. Если Компонент не будет найден в кэше, фреймворк выбросит исключение! Поэтому, необходимо на этапе создания Сущности добавить в нее все Компоненты, которые у нее могут быть в рантайме и тут же закэшировать ненужные в данный момент Компоненты путем удаления их из Сущности.

```
import { v4 as uuidv4 } from 'uuid';

const id: string = uuidv4();
const player: IEntity<IComponent> = new BaseEntity(id);

const components: IComponent[] = [new PlayerComponent(), new HealthComponent(100)];
const cached: IComponent[] = [new HitByEnemyComponent()];

player.components.push(...components, ...cached);
cached.forEach(c => player.remove(c.constructor.prototype.constructor));
```
В примере наглядно показано как мы создаем Сущность, определяем массив с Компонентами, которые необходимы ей при инициализации, определяем массив Компонентов, которые будут задействованы позже, устанавливаем два набора Компонентов Сущности, а после удаляем те, которые должны попасть в кэш. Таким образом, мы на этапе инициализации выделили под всю нашу Сущность память, тем самым оптимизировав работу Сборщика мусора, что положительно сказывается на производительности, особенно на слабых устройствах.
Однако, нужно помнить, что при попадании Компонента в кэш он сохраняет свое текущее состояние! Для того, чтобы манипулировать состоянием Компонента необходимо использовать инструмент, описанный в разделе “Контроль состояния Компонентов”.

Впрочем, если механизм кэширования Компонентов не требуется, его можно отключить, передав в конструктор Сущности вторым аргументом значение false;

```
import { v4 as uuidv4 } from 'uuid';

const id: string = uuidv4();
const player: IEntity<IComponent> = new BaseEntity(id, false);
```

### Доступ к Ноде игрового движка.

В целях возможности интеграции Cramp с движками использующих древовидную структуру организации объектов на сцене, таких как CocosCreator или PlayCanvas, существует отдельный класс для Сущности NodeEntity, который наследует функционал класса BaseEntity и предоставляет ссылку на Ноду через свойство node. Таким образом, мы моем в Системах обращаться к ноде, которая привязана к Сущности и проводить над ней нужные манипуляции.

```
import { v4 as uuidv4 } from 'uuid';

//…

const id: string = uuidv4();
const player: IEntity<IComponent> = new NodeEntity(id);
player.node = this.node;
```

### Фабрики Сущностей.

Для упрощения создания новых Сущностей, а также для организации кода, Cramp предоставляет фабрики Сущностей, в которых можно быстро и удобно собирать Сущности, сохраняя при этом порядок и чистую организацию в коде.

```
class PlayerFactory implements IEntityFactory<IComponent, IEntity<IComponent>, number> {
	create(id: string, data: number): IEntity<IComponent> {
		const player = new BaseEntity(id);
		player.components.push(new HealthComponent(data));
		return player;
	}
}
```

Фабрика Сущностей в Cramp это всего-лишь интерфейс, который описывает метод create(id: string, data?: T): IEntity<IComponent>. Метод принимает в качестве параметров id Сущности в строковом виде и, опционально, данные для компонентов. Тип данных для Компонентов указывается в дженерике интерфейса фабрики. А возвращает уже готовую Сущность.

Если вы используете Cramp с CocosCreator или PlayCanvas, механизм создания Сущностей там немного отличается и Фабрики Сущностей не требуются. 


### Хорошие практики при работе с Сущностями.

* Не отключайте кэширование Компонентов. Выделяйте память под них заранее! Это поможет избежать микрофризов на слабых устройствах, вызванных активной работой с Компонентами у Сущности.
* Пользуйтесь Фабриками Сущностей, если они применимы в окружении в котором работаете. Фабрики позволяют удобно организовывать код, держа все Сущности отдельно друг от друга.


## Хранилища Сущностей

Логично, что все созданные пользователем Сущности необходимо где-то хранить, чтобы Системы и другие части приложения могли иметь к ним доступ. Для хранения в Cramp предусмотрены Хранилища, которые предоставляют удобный и простой способ хранения и доступа.


### Пример использования Хранилища Сущностей.

```
const entityStorage: IEntityStorage<IEntity<IComponent>> = new EntityStorage();
const player = new Entity('0');
const enemy = new Enemy('1');

entityStorage.add(player, enemy);
```

У каждого созданного Хранилища Сущностей есть API для доступа к Сущностям, однако, он используется Контейнером Систем для выборки и передачи Сущностей Системам в зависимости от указанного фильтра. Одним словом, пользователю не придется получать Сущности напрямую и самостоятельно. Прямой доступ к Сущностям хоть и возможен, но противоречит основным идеям Cramp и паттерна Entity-Component-System.


### Создание Хранилищ через Фабрики.
```
// Создаем Хранилище через фабрику реализованную в методе create класса GlobalEntitiesStorage.
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('GAME');

// Получаем доступ к ранее созданному Хранилищу с id Game
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.get('GAME')

// Удаляем ранее созданное Хранилище с id Game
GlobalEntitiesStorage.remove('GAME')
```

Хорошей практикой будет создавать все Хранилища через Фабрики. Да, Хранилищ в приложении может быть несколько. Более того, необходимо создавать несколько Хранилищ для оптимизации производительности. Фабрика для создания Хранилищ уже предоставлена самим фреймворком. Достаточно лишь вызвать статический метод create() у класса GlobalEntitiesStorage, передав ему уникальный идентификатор, который вернет экземпляр Хранилища.
В дальнейшем, если нам необходимо получить доступ к Хранилищу, мы также можем сделать это через класс GlobalEntitiesStorage, обратившись к методу get(), которому необходимо передать уникальный идентификатор, который мы указывали при создании Хранилища. Метод get() вернет нам экземпляр ранее созданного Хранилища. 

И для удаления, если это необходимо, мы можем воспользоваться методом remove(), который принимает уникальный идентификатор ранее созданного Хранилища в качестве аргумента.


### Комбинирование Хранилищ.

Бывают случаи, когда нам требуется использовать несколько Хранилищ одновременно. Для этого в Cramp существует механизм Комбинирования, который создает новое Хранилище на основе нескольких ранее созданных, не меняя исходные Хранилища. 

```
const combinedEntityStorage = GlobalEntitiesStorage.combine(
	‘GAME_UI_COMBINED’,
	[‘GAME’, ‘UI’]
)
```
Для того, чтобы скомбинировать Хранилища, необходимо вызвать статический метод create() у класса GlobalEntitiesStorage, в который необходимо передать уникальный идентификатор нового Хранилища и массив из уникальных идентификаторов ранее созданных Хранилищ. Таким образом, мы получим новое Хранилище, которое хранит в себе все Сущности из других Хранилищ. 

Если нам потребуется обратится к комбинированному Хранилищу в другом месте, нам не нужно комбинировать его заново, мы используем метод get(), как в случае со стандартными Хранилищами.

Важно понимать, что Комбинированное Хранилище хранит в себе ссылки Сущности из исходных Хранилищ. Поэтому, если мы удалим или добавим сущность в Хранилище GAME, например, то она также пропадет из всех комбинированных Хранилищ, которые используют в качестве основы Хранилище GAME.


### Хорошие практики при работе с Хранилищами.

* Не стоит бояться создавать как можно больше Хранилищ Сущностей, наоборот, это необходимо, чтобы оптимизировать производительность во время работы. К Хранилищам всегда можно быстро и удобно получить доступ из любого места, если это необходимо. Также их можно Комбинировать, расширяя диапазон обрабатываемых Сущностей.


## Системы в Cramp.

Системы в Cramp выполняют свою изначальную функцию Систем в любой Entity-Component-System реализации. В Системах описывает вся логика работы с данными Компонентов, а также производится получение всех необходимых для ее работы Сущностей.


### Пример создания Системы в Cramp.

```
export default class IncreaseHealthSystem extends BaseSystem<number, IEntity<IComponent>> {

	public filter(): ComponentFilter {
		return {
			include: [HealthComponent, NeedHealComponent]
		}
	}

	public execute(entities: IEntity<IComponent>[], data: number) {
		entities.forEach(entity => {
			const health = entity.get(HealthComponent);
			health.value -= data;
		
			entity.remove(NeedHealComponent);
		})
	}

}
```


### Объект фильтрации Компонентов.

Чтобы Система работала, ей необходимо получить Сущности. Мы знаем, что напрямую получать конкретные Сущности противоречит идеологии Entity-Component-System. Мы можем лишь получать набор Компонентов. Поэтому, в Cramp существует специальный объект ComponentFilter, который помогает запрашивать необходимые для работы Системы Сущности. 

Объект состоит из двух свойств: include и exclude хранящих в себе массивы с Компонентами. Как понятно из названия, include содержит в себе Компоненты, которые должны быть у Сущности, а exclude - которых не должно быть.

```
public filter(): ComponentFilter {
	return {
		include: [HealthComponent, NeedHealComponent],
		exclude: [IsDeadComponent]
	}
}
```
В данном примере объект фильтрации говорит фреймворку “Дай этой Системе все Сущности у которых есть Компоненты HealthComponent и NeedHealComponent, но нет компонента isDeadComponent”. В итоге в Систему попадут все Сущности с Компонентами HealthComponent и NeedHealComponent, но не попадут все Сущности с Компонентами HealthComponent, NeedHealComponent и IsDeadComponent.

Стоит понимать, что если у Сущности будут и другие Компоненты, помимо тех, которые требуются фильтром, Сущность все также попадет под параметры фильтрации и будет передана Системе, при условии, что не было указано исключений в поле exclude.

Рекомендуется не использовать поле exclude внутри Системы, чтобы сделать ее более универсальной. Для того, чтобы ограничить Сущности передаваемые в данную Систему, существует механизм декораций о которых будет рассказано в разделе “Контейнеры в Cramp”.


Для того, чтобы создать Систему, необходимо просто создать новый класс и унаследовать его от класса BaseSystem. У Системы есть два метода: filter() и execute(), которые должны быть переопределены пользователем. Работа каждой Системы начинается с метода filter(), который возвращает специальный объект фильтрации. По сути, этот объект говорит фреймворку какие типы Сущностей нужны этой Системе. В данном случае, мы говорим фреймворку, что хотим получить все Сущности у которых есть Компоненты HealthComponent и NeedHealComponent. 

После того, как все Сущности найдены, они передаются методу execute(), где и происходит выполнение всей логики. Важно понимать, что если Сущности не были найдены, то метод execute() все равно отработает. Если же Сущности найдены, мы можем обойти их, получить все нужные Компоненты и произвести необходимые манипуляции с данными. Допустим, у нас в проекте есть Player, Enemy, NPC, Animal. Если у них у всех есть запрашиваемые Компоненты, то все они попадут в массив entities, которые передается аргументов в метод execute().

Метод execute() также может принимать какие-то данные извне, однако, это используется достаточно редко, поэтому аргумент data является опциональным, а в дженерике интерфейса Системы зачастую указывается undefined или null.


### Хорошие практики при работе с Системами в Cramp.

* Каждая Система должна следовать принципу Single Responsibility. Для сохранения универсальности и расширяемости Системы должны отвечать за одно действие. Если Система перемещает объект, она не может красить его в другой цвет или производить какие-либо другие манипуляции. Системы, подобно Компонентам, лишь небольшие кирпичики, из которых можно выстраивать комплексную логику всего игрового приложения. И чем меньше эти кирпичики, тем проще их использовать.

* Для объекта фильтрации используйте защищенное поле componentFilter, что обеспечит его кеширование и объект не будет создаваться каждый вызов метода filter(). Да и сам метод в таком случае не придется переопределеять.
```
export default class IncreaseHealthSystem extends BaseSystem<number, IEntity<IComponent>> {

	protected readonly componentFilter: ComponentFilter = {
		include: [HealthComponent, NeedHealComponent]
	}

	public execute(entities: IEntity<IComponent>[], data: number) {
		entities.forEach(entity => {
			const health = entity.get(HealthComponent);
			health.value -= data;
			
			entity.remove(NeedHealComponent);
		})
	}

}
```

* Запрашивайте у полученных Сущностей только те Компоненты, которые были указаны в объекте фильтрации.

* В примерах для итерации Сущностей используется forEach, но это не рекомендуется делать во избежание проблем с производительностью. Стандартный цикл for работает быстрее и рекомендуется использовать для итерации Сущностей именно его.Впрочем, это вопрос микро-оптимизации. 

* У каждой Системы есть ссылка на Хранилище Сущностей. Не стоит работать с ним напрямую, однако, его можно использовать для передачи различным инструментам представленным в фреймворке, например, как Кэширование Сущностей.


## Контейнеры Систем.

В Cramp Контейнеры Систем играют такую же важную роль, как Системы, Сущности и Компоненты. Основная задача Контейнера Систем - последовательный запуск каждой предустановленной в Контейнере Системы. Но сам Контейнер запускается во время некоего внутриигрового события. Событием может быть что угодно: от клика мыши, до изменения данных в Компоненте. Типичный порядок выполнения кода выглядит примерно так: происходит событие > запускается Контейнер > выполняются все Системы в текущем Контейнере. 


### Пример создания и запуска Контейнера.

Разберем подробнее, как создается, запускается и работает Контейнер. 
```
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('Game');
const container = new SystemsContainer(entityStorage);

container.add(ExampleOneSystem);
container.add(ExampleTwoSystem);
container.add(ExampleThreeSystem);

document.addEventListener(‘click’, () => container.execute(), false);
```

При создании, каждый Контейнер в качестве аргумента в свой конструктор принимает ссылку на Хранилище Сущностей. Это необходимо для того, чтобы Контейнер передавал своим Системам необходимые им Сущности. Контейнер вызывает метод filter() у Системы, получает массив с требуемыми Компонентами, забирает все Сущности с необходимым набором Компонентов у Хранилища и передает их в метод execute() Системы. 

С помощью метода add(), мы наполняем наш Контейнер Системами. И все они будут выполнены именно в том порядке, в котором были добавлены при вызове метода execute() у Контейнера. В данном случае, сначала выполнится ExampleOnSystem, затем ExampleTwoSystem и в самом конце - ExampleThreeSystem. Все Системы существуют в единственном экземпляре во всем приложении. Мы без проблем можем добавлять одну и ту же Систему в различные Контейнеры, либо использовать ее несколько раз в одном и том же Контейнере. Система будет создана лишь раз, при первом добавлении в любой из Контейнеров, а далее она будет переиспользоваться, что положительно сказывается на выделении памяти.

Метод execute() у Контейнера стоит вызывать во время некоторого события. Как было сказано ранее: событием может быть все, что угодно: от клика мышью по игровому полю, до ответа от сервера. Метод execute() может принимать некоторые данные и передавать их Системам в Контейнере, что бывает иногда полезно.
По сути, Контейнеры что-то вроде сценария. А если точнее, это такой большой кусок логики, составляемый из более мелких логических частей - Систем. С помощью них очень просто описывать действия, которые должны быть выполнены в тот или иной момент. Например, мы могли бы создать Контейнер со всеми Системы, которые должны быть выполнены во время нажатия на клавишу передвижения и запустить все Системы, которые отвечают за движения игрока - от смены позиции в игровом мире, до запуска анимации. Либо, создать Контейнер, который бы описывал поведение объектов во время коллизии. Не смотря на то, что Системы добавляются в Контейнер, они все еще ничего не знают друг о друге и никак не связаны между собой, они лишь выполняются в том порядке, в котором были установлены. Однако, Контейнер в Cramp это нечто большее, чем последовательный запуск Систем…


### Декораторы Систем.

Бывают случаи, когда у нас есть Система, функционал которой необходимо расширить в определенный момент. Для этого в Cramp предусмотрены Декораторы и Системы-декораторы, что обеспечивает максимальную гибкость и устойчивость нашего приложения. 

Допустим, у нас есть Система, которая просто выводит в консоль какое-то сообщение:
```
class ConsoleLogSystem extends extends BaseSystem<undefined, IEntity<IComponent>> {
	execute(entities: IEntity[]): void {
		console.log(`Hello, i’am System!`);
	}
}
```
Но что, если нам вдруг понадобилось расширить этот функционал? Следуя принципу Open\Closed мы не имеем права менять исходный код нашей ConsoleLogSystem, ведь это гарантированно изменит ее работу в других местах, чего нам бы не хотелось. Выход прост: использовать Систему Декоратор и применять ее к изменяемой Системе в Контейнере. Для этого нам необходимо создать еще одну Систему, но использовать ее свойство subsystem, которое хранит в себе ссылку на оборачиваемую Систему.

```
class ConsoleLogSystemDecorator extends BaseSystem<any, IEntity<IComponent>> {
	filter(): ComponentFilter {
		return this.subsystem.filter();
	}

	execute(entities: IEntity[], data?: any): void {
		console.log(`Hello, i’am Decorator!`);
		this.subsystem.execute(entities);
	}
}
```
Свойство subsystem это ссылка на Систему, которую мы оборачиваем этим декоратором. Следуя из этого, мы можем вызывать методы filter() и execute() дочерней Системы, возвращая первый из метода filter() декоратора и передавать во второй все Сущности и данные. 

Для того, чтобы применить декоратор, необходимо вызвать метод decorate() в Контейнере при добавлении Системы:
```
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('Game');
const container = new SystemsContainer(entityStorage);

container.add(ExampleOneSystem)

container
	.add(ConsoleLogSystem)
	.decorate(ConsoleLogSystemDecorator)

container.add(ExampleTwoSystem);

document.addEventListener(‘click’, () => container.execute(), false);
```
При вызове метода decorator() Декоратор обернет ту Систему, которая добавляется в Контейнер при вызове метода add(). То есть, в данном примере, Декоратор будет применен к ConsoleLogSystem, но не к ExampleOneSystem и ExampleTwoSystem.

Таким образом, мы смогли расширить функционал ConsoleLogSystem не меняя ее исходный код. И в других Контейнерах наша ConsoleLogSystem будет, как и раньше, выводить всего одно сообщение в консоль, а в этом два.

```
// Вызов ConsoleLogSystem из какого-то другого Контейнера
> Hello, i’am System!

// Вызов ConsoleLogSystem из Контейнера в котором был установлен Декоратор для этой Системы
> Hello, i’am Decorator!
> Hello, i’am System!
```

Метод decorate() может принимать в себя любое количество Систем-декораторов, через запятую. Все они обернут друг-друга в порядке добавления, а последней в цепочке вызовов будет исходная Система.
```
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('Game');
const container = new SystemsContainer(entityStorage);

container.add(ExampleOneSystem)

container
	.add(ConsoleLogSystem)
	.decorate(HighLevelDecorator, ConsoleLogSystemDecorator)

container.add(ExampleTwoSystem);

document.addEventListener(‘click’, () => container.execute(), false);
```

В таком случае результат работы будет выглядеть примерно так:
```
> Hello, i’am High Level Decorator!
> Hello, i’am Decorator!
> Hello, i’am System!
```

Как видно, Декораторы это достаточно мощный инструмент позволяющий расширять поведение отдельно взятых Систем в отдельно взятых Контейнерах, не меняя исходного кода самой Системы. Однако, не стоит ими злоупотреблять, ведь большая часть задач по модификации функционала решается последовательным вызовом Систем. Ведь Контейнер по сути своей тоже модифицирует поведение Систем поочередно вызывая каждую из них. Например, чтобы запустить анимацию передвижения игрока в то время как он меняет свое положение в игровом мире, нам не нужно ничего декорировать, достаточно вызвать две Системы подряд. Поэтому будьте внимательны и осторожны с декораторами!


### Декораторы фильтра.

Помимо декорации логики Системы, мы также можем декорировать ее фильтр, сужая область поиска среди Сущностей. И как в случае с Декораторами Систем, мы делаем это извне, не затрагивая исходный код существующей Системы. Но в отличии от декорации логики, нам не нужно создавать дополнительных классов для этого. 

Допустим, у нас есть два игровых объекта, которые должны перемещаться по пространству. Например, это будет объект Игрока и NPC. Логика передвижения у них одинаковая, поэтому нам не нужно описывать две разные Системы, хватит и одной, просто вызывать мы ее будем в двух разных Контейнерах, которые в свою очередь вызываются при двух разных событиях.

Создадим логику передвижения игрового объекта:
```
class MovementSystem extends BaseSystem<any, IEntity<IComponent>> {
	protected readonly componentFilter: ComponentFilter = {
		return include: [PositionComponent, SpeedComponent]
	}

	execute(entities: IEntity[], data?: any): void {
		entities.forEach(entity => {
			const position = entity.get(PosiitionComponent);
			const speedt = entity.get(SpeedComponent);
			
			position.value.x += speed.value.x;
		})
	}
}
```

Данная Система будет перемещать все Сущности у которых есть Компоненты PositionComponent и SpeedComponent по оси x вправо. Предположим, что у наших Сущностей Player и NPC есть эти Компоненты. Теперь опишем для них Контейнеры и вызовем во время двух разных событий:

```
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('Game');

const playerMovementContainer= new SystemsContainer(entityStorage);
const npcMovementContainer= new SystemsContainer(entityStorage);

playerMovementContainer.add(MovementSystem);
npcMovementContainer.add(MovementSystem);

KeyboardController.onKeyDown(Key.Left, playerMovementContainer.execute());
AIController.onMovement(npcMovementContainer.execute());
``` 

И тут мы должны столкнутся с проблемой: оба события будут перемещать как Игрока, так и NPC. Ведь в обеих случаях, оба этих объекта попадают под условие фильтрации и будут обработаны MovementSystem, установленной в разных контейнерах. Решение достаточно простое: нам необходимо добавить к PlayerEntity и NPCEntity по Компоненту PlayerComponent и NPCComponent. PlayerComponent будет добавлен к PlayerEntity, а NPCComponent к NPCEntity соответственно. Теперь же, все что нужно сделать, это воспользоваться методом include() в Контейнерах и передать им новые Компоненты:
```
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('Game');

const playerMovementContainer= new SystemsContainer(entityStorage);
const npcMovementContainer= new SystemsContainer(entityStorage);

playerMovementContainer
	.add(MovementSystem)
	.include(PlayerComponent);

npcMovementContainer
	.add(MovementSystem)
	.include(NPCComponent);

KeyboardController.onKeyDown(Key.Left, playerMovementContainer.execute());
AIController.onMovement(npcMovementContainer.execute());
``` 
Теперь все будет работать так, как и задумывалось: в Контейнере playerMovementContainer в MovementSystem будут попадать все Сущности с набором Компонентов PositionComponent, SpeedComponent и PlayerComponent. А в MoveSystem, которая находится в npcMovementContainer будут попадать все Сущности с набором Компонентов PositionComponent, SpeedComponent и NPCComponent. И оба эти Контейнера хоть и работают с одной и той же Системой, будут передавать им разные Сущности. Таким образом, у нас есть одна абстрактная Система, которая может передвигать объекты с Компонентами PositionComponent и SpeedComponent, но благодаря декорации фильтра мы можем использовать ее для разных объектов, а не для всех сразу. И если вспомнить, что Системы существуют в Cramp в единственном экземпляре, получается, что одна единственная Система может манипулировать с разными объектами в разных местах. При этом нам не пришлось менять ее исходный код, дублировать, создавать дополнительные Системы-декораторы и вообще хоть как-то влиять - наша абстрактная Система отвечающая за перемещение игрового объекта никак не затронута.

Метод include() по принципу работы схож с методом decorate() - он также вызывается после вызова метода add(), также может принимать в себя неограниченное количество Компонентов через запятую. Единственное, что он модифицирует возвращаемый из Системы фильтр, а точнее, поле include, как ясно из названия метода. 

У метода include() есть брат exclude(), который делает ровно тоже самое, но с полем exclude объекта фильтра.


### Отложенный запуск Систем.

Бывают случаи, когда нам необходимо приостановить на время выполнение Систем в Контейнере. Например, дождаться выполнения анимации, прежде, чем выполнять последующие Системы в цепочке вызовов. Для таких целей имеется метод sleep(), который может отложить выполнение последующих в цепочке вызовов Систем на какое-то время.
```
const entityStorage: IEntityStorage<IEntity<IComponent> = GlobalEntitiesStorage.create('Game');
const container = new SystemsContainer(entityStorage);

container.add(ExampleOneSystem);

container
	.add(ExampleTwoSystem)
	.sleep(2000);

container.add(ExampleThreeSystem);

document.addEventListener(‘click’, () => container.execute(), false);
```
В примере Системы будут выполняться следующим образом: Сначала выполнится ExampleOneSystem, затем сразу же после окончания выполнения ExampleOneSystem будет выполнена ExampleTwoSystem. И после того, как ExampleTwoSystem будет выполнена, Система ExampleThreeSystem выполнится по истечению двух секунд.


### Хорошие практики при работе с Контейнерами.

* Под каждое внутриигровое событие, будь то клик мышью или изменение данных в Компоненте создавайте новый Контейнер, даже, если он похож на один из уже существующих.

* Старайтесь писать абстрактные Системы. Если есть Система, которая перемещает объекты в игровом пространстве, не указывайте в фильтре компонентов Системы с какими именно объектами может работать Система. Это всегда можно сделать в декораторе фильтра Контейнера. 

* Всегда пробрасывайте данные в метод execute() дочерней Системы из Системы-декоратора, даже, если Система-декоратор не принимает данные из Контейнера в данный момент.

* Вы можете использовать функцию sleep() и внутри Систем. Их API подразумевает асинхронность. Однако, рекомендуется пользоваться декоратором sleep() в Контейнерах. 


## Реакция на изменение Компонентов.

Зачастую необходимо отслеживать события, которые происходят с Компонентами внутри Сущностей. Будь то удаление, добавление самого Компонента или изменение данных в нем. Для этого предоставляется специальный статический класс ComponentChangesController, через который будут прослушиваться и инициироваться данные события.

```
// ...В какой-то из Систем
execute(entities: IEntity<IComponent>[]): void {
	entities.forEach(entity => {
		// Изменение данных в Компоненте
		ComponentChangesController.change(entities[i], HealthComponent, {value: 20});
		
		// Добавление Компонента
		ComponentChangesController.attach(entities[i], ManaComponent);

		// Удаление Компонента
		ComponentChangesController.deattach(entities[i], ManaComponent);
	})
}
```

Для того, чтобы сообщить всем подписчикам о том, что что-то изменилось, все манипуляции с Сущностями и Компонентами должны происходить через методы статического класса ComponentChangesController, которые принимают Сущность и Компонент с которыми проводятся манипуляции, а также объект изменений данных. Который, к слову, является типобезопасным и будет принимать только те поля и значения, которые указаны в самом Компоненте.

Для прослушки события необходимо использовать метод подписки у статического класса ComponentChangesController в котором мы указываем за каким именно типом события, в каких сущностях и за манипуляциями с каким именно Компонентом мы должны следить:
```
ComponentChangesController.subscribe({
	in: [PlayerComponent, HealthComponent], 
	on: ComponentEvent.Attach, 
	component: HasDamageComponent, 
	execute: () => damageContainer.execute()
})
```

Данный блок кода можно читать как: Когда к одной из Сущностей с Компонентами PlayerComponent и HealthComponent добавится Компонент HasDamageComponent запусти работу Контейнера HasDamageContainer. То есть, как только мы в одной из Систем, использующих в своей работе Сущность с набором Компонентов PlayerComponent и HealthComponent, вызовем метод attach() у ComponentChangesController и передадим туда HasDamageComponent, сработает событие и обработчик его подхватит. Таким образом, мы можем запускать работу Контейнеров.

### Хорошие практики при работе с Реакциями на изменения Компонентов.

* Старайтесь сильно не злоупотреблять этой возможностью, поскольку она достаточно тяжела в обработке.


## Модули Cramp.

Во избежание бардака из огромной кучи Компонентов, Систем, Контейнеров и прочего, фреймворк предоставляет небольшое структурное решение. Пользоваться им или нет - решать пользователю, однако, простое решение поможет поддерживать порядок в коде и упростит переносимость функционала из проекта в проект.

Для начала стоит определится со структурой папок, обычно выглядит модуль следующим образом:
```
MovementModule
|--components
|----speed.component.ts
|----position.component.ts
|--systems
|----movement.system.ts
|--containers
|----move.container.ts
|--movement.module.ts

```

Также, необязательным, но возможным, есть создание точки входа в модуль. Это небольшой класс наследующий интерфейс ICrampModule, у которого есть всего три метода init(), execute() и destroy(). Иногда бывает удобно создавать точку входа, создавать в ней контейнеры и подвязывать их на внутренние игровые события.

```
class MovementModule implements ICrampModule<any> {

	private _entityStorage: IEntityStorage<IEntity<IComponent>> = null; 
	private _moveContainer: ISystemsContainer<any> = null;

	constructor(entityStorage: IEntityStorage<IEntity<IComponent>>) {
		this._entityStorage = entityStorage; 
	}

	init() { 
		this._moveContainer = new SystemsContainer(this._entityStorage); 
	}

	execute(data: any): void { 
		this._moveContainer.execute(data); 
	}

	destroy(): void {}
}
```

Модули могут без проблем использовать части других Модулей. Однако, стоит это учитывать при переносе Модулей в другие проекты. 


## Контроль состояния Компонентов.

Нередко бывает необходимо откатывать состояние определенных Компонентов, например, при взятии Компонента из кэша и передачи его Сущности. Для этих целей в версии 1.2 был добавлен специальный статический класс ComponentStateController, который умеет запоминать состояние Компонента и при необходимости, возвращать Компонент к нужному состоянию. 

Для того, чтобы возвращать Компоненты к стартовому состоянию, необходимо при их создании и передачи Сущности передать методу takeSnapshot статического класса ComponentStateController:

```
class PlayerFactory implements IEntityFactory<IComponent, IEntity<IComponent>, number> {
	create(id: string, data: number): IEntity<IComponent> {
		const player = new BaseEntity(id);
		
		const components: IComponent[] = [
			ComponentStateController.takeSnapshot(player, new HealthComponent(data))
		];

		player.components.push(...components);
		return player;
	}
}
```
Таким образом, мы запишем стартовое состояние Компонента и сможем вернутся к нему в любой момент. Вообще-то метод takeSnapshot() принимает и третий аргумент - айди состояния. Это ключ по которому мы сможем потом обратиться к нужному состоянию Компонента. Но по умолчанию, если аргумент айди не указан, состояние запишется под ключом ‘initial’.

Для того, чтобы откатить состояние Компонента к одному из записанных состояний, необходимо вызвать метод setStateBySnapshot() у статического класса ComponentStateController. Этот метод принимает ровно те же самые параметры, что и takeSnapshot(). И даже, если не укажем айди для состояния, будет взято то, которое записано под ключом ‘initial’


# Так как же это все работает

Порядок выполнения достаточно простой и последовательный и един для всех кейсов:

- Инциируется некоторое событие. Это может быть как ответ от сервера, нажатие клавиши клавиатуры, тач-событие, так и реакция на изменения в Компонентах.

- Запускается Контейнер, который последовательно начинает выполнять все установленные в нем Системы с учетом всех декораторов.

- Как только Контейнер начал выполнять Систему, он передает ее фильтр Хранилищу Сущностей, получает все найденные Сущности и выполняет Систему.

- Идет выполнение самой Системы, если условия фильтрации были удовлетворены. Однако, Система в любом случае выполнится хотя бы раз!

- Как только Система закончила свое выполнение, Контейнер переходит к выполнению другой Системы и так до конца.

- Как только все Системы в Контейнеры выполнены, Контейнер завершает свою работу, сбрасывая свое состояние до изначального, что позволяет использовать его еще раз.

## Простой пример

Для наглядности ниже приведен пример создания приложения в одном файле. В примере будет создано два объекта, которые будут двигатся с разной скоростью по нажатию на клавиши управления.

Создание классов Компонентов:
```
class SpeedComponent implements IComponent {
	x: number = 0;
	y: number = 0;

	constructor(x: number, y: number) {
		this.x = x;
		this.y = y;
	}
}

class PositionComponent implements IComponent {
	x: number = 0;
	y: number = 0;
}
```

Создание класса Системы, которая будет запрашивать все Сущности с Компонентами SpeedComponent и PositionComponent, и в случае успеха приводить объекты в движение:
```
type MovementDelta = {
	x: number,
	y: number
}

class MovementSystem extends BaseSystem<MovementDelta, IEntity<IComponent>> {

	protected readonly componentFilter: ComponentFilter = {
		include: [SpeedComponent, PositionComponent]
	}

	public execute(entities: IEntity<IComponent>, delta: MovementDelta): void {
		for(let i = 0; i < entities.length; i++) {
			const speed: SpeedComponent = entities[i].get(SpeedComponent);
			const position: PositionComponent = entities[i].get(PositionComponent);

			position.x += speed.x * delta.x;
			position.y += speed.y * delta.y;
		}
	}

}
```

Теперь инициализируем приложение:
```
// Создадим Хранилище
const entityStorage: IEntityStorage<IEntity<IComponent>> = GlobalEntitiesStorage.create('Game');

// Создадим Сущности машин инаделим их нужными Компонентами
const carOne = new Entity('car_1');
carOne.components.push([new SpeedComponent(1, 0), new PositionComponent()]);

const carTwo = new Entity('car_2');
carTwo.components.push([new SpeedComponent(2, 0), new PositionComponent()]);

// Добавим Сущности в Контейнер
entityStorage.add(carOne, carTwo);

//Создадим Контейнер, передадим в него Хранилище с Сущностями и установим Систему для выполнения.
const carMovedContainer: ISystemsContainer<MovementDelta> = new SystemsContainer(entityStorage)
carMovedContainer.add(MovementSystem)

// Повесим обработчик событий на нажатие клавиш и создадим объект дельты направления движения,
// который будем передавать Системе через Контейнер

document.addEventListener('keydown', event => {
	const movementDelta: MovementDelta = {x: 0, y: 0}

	if(event.key === 'ArrowLeft') movementDelta.x = 1;
	if(event.key === 'ArrowRight') movementDelta.x = -1;

	carMovedContainer.execute(movementDelta);
}, false);
```

Вот и все. Создание более крупных и сложных приложений нчием не отличается от того, что было показано в примере. Разумеется, необходимо пользоваться Фабриками, не забывать про разделения Хранилищь, кэшировании, принципах проектирования, однако все это достаточн оподробно расписано в документации выше. 

## Более подробные примеры

Cramp API Example: https://github.com/YettiKetchup/cramp-pure-example